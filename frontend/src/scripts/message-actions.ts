/**
 * Message Actions - Copy to clipboard and download as markdown/PDF/DOCX/text
 */

import { updateButtonFeedback, downloadFile, getFileTimestamp } from './utils';

// Declare global types for export libraries
declare const html2pdf: {
  (): {
    set(options: Record<string, unknown>): ReturnType<typeof html2pdf>;
    from(element: HTMLElement | string): ReturnType<typeof html2pdf>;
    save(): Promise<void>;
  };
};

declare const htmlDocx: {
  asBlob(html: string, options?: { orientation?: string; margins?: Record<string, number> }): Blob;
};

export const MessageActions = {
  /**
   * Copy text to clipboard and update button icon
   */
  async copyToClipboard(text: string, buttonEl: HTMLElement): Promise<void> {
    try {
      await navigator.clipboard.writeText(text);

      // Update icon to success state with auto-revert
      const icon = buttonEl.querySelector('i') as HTMLElement | null;
      if (icon) {
        updateButtonFeedback(buttonEl, icon, 'bi-clipboard', 'bi-clipboard-check', ['text-success'], ['text-muted']);
      }
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      // Fallback for older browsers
      this.fallbackCopyToClipboard(text);
    }
  },

  /**
   * Fallback copy method for browsers without clipboard API
   */
  fallbackCopyToClipboard(text: string): void {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (err) {
      console.error('Fallback copy failed:', err);
    }
    document.body.removeChild(textArea);
  },

  /**
   * Download text as markdown file
   */
  downloadAsMarkdown(text: string, buttonEl: HTMLElement): void {
    const filename = `kea-answer-${getFileTimestamp()}.md`;
    downloadFile(text, filename, 'text/markdown;charset=utf-8');

    // Show success feedback with auto-revert
    const icon = buttonEl.querySelector('i') as HTMLElement | null;
    if (icon) {
      updateButtonFeedback(buttonEl, icon, 'bi-filetype-md', 'bi-check-lg', ['text-success'], ['text-muted']);
    }
  },

  /**
   * Download as PDF using html2pdf.js
   */
  downloadAsPDF(text: string, renderedHtml: string, buttonEl: HTMLElement): void {
    const filename = `kea-answer-${getFileTimestamp()}.pdf`;

    // Create a temporary container with forced dark text for PDF (white background)
    const container = document.createElement('div');
    container.innerHTML = `
      <div style="font-family: system-ui, -apple-system, sans-serif; padding: 20px; max-width: 800px; color: #000; background: #fff;">
        <h1 style="color: #323b1c; margin-bottom: 20px;">KEA Research Answer</h1>
        <div style="line-height: 1.6; color: #000;">${renderedHtml}</div>
        <hr style="margin-top: 30px; border: none; border-top: 1px solid #ddd;">
        <p style="color: #666; font-size: 12px;">Generated by KEA Research on ${new Date().toLocaleDateString()}</p>
      </div>
    `;
    // Force all text elements to have dark color
    container.querySelectorAll('*').forEach(el => {
      (el as HTMLElement).style.color = '#000';
    });
    // Restore header color
    const h1 = container.querySelector('h1');
    if (h1) h1.style.color = '#323b1c';
    const footer = container.querySelector('p:last-child');
    if (footer) (footer as HTMLElement).style.color = '#666';

    const opt = {
      margin: 10,
      filename: filename,
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 2, useCORS: true, backgroundColor: '#ffffff' },
      jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
    };

    html2pdf().set(opt).from(container).save().then(() => {
      // Show success feedback
      const icon = buttonEl.querySelector('i') as HTMLElement | null;
      if (icon) {
        updateButtonFeedback(buttonEl, icon, 'bi-file-earmark-pdf', 'bi-check-lg', ['text-success'], []);
      }
    });
  },

  /**
   * Download as Word document using html-docx-js
   */
  downloadAsDOCX(text: string, renderedHtml: string, buttonEl: HTMLElement): void {
    const filename = `kea-answer-${getFileTimestamp()}.docx`;

    // Strip inline color styles from rendered HTML (dark mode colors won't show on white background)
    const cleanedHtml = renderedHtml.replace(/style="[^"]*color:[^"]*"/gi, '');

    // Create HTML document structure for DOCX with explicit dark text
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Calibri, sans-serif; line-height: 1.6; color: #000000; }
          * { color: #000000; }
          h1 { color: #323b1c; }
          h2, h3, h4 { color: #000000; }
          pre { background: #f5f5f5; padding: 10px; color: #000000; }
          code { font-family: Consolas, monospace; color: #000000; }
          p { color: #000000; }
          li { color: #000000; }
        </style>
      </head>
      <body>
        <h1>KEA Research Answer</h1>
        ${cleanedHtml}
        <hr>
        <p style="color: #666666; font-size: 10pt;">Generated by KEA Research on ${new Date().toLocaleDateString()}</p>
      </body>
      </html>
    `;

    const blob = htmlDocx.asBlob(htmlContent, { orientation: 'portrait' });
    downloadFile(blob, filename, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');

    // Show success feedback
    const icon = buttonEl.querySelector('i') as HTMLElement | null;
    if (icon) {
      updateButtonFeedback(buttonEl, icon, 'bi-file-earmark-word', 'bi-check-lg', ['text-success'], []);
    }
  },

  /**
   * Convert markdown to plain text by stripping formatting
   */
  markdownToPlainText(markdown: string): string {
    return markdown
      // Remove code blocks (```...```)
      .replace(/```[\s\S]*?```/g, (match) => match.replace(/```\w*\n?/g, '').trim())
      // Remove inline code (`...`)
      .replace(/`([^`]+)`/g, '$1')
      // Remove bold/italic (**, __, *, _)
      .replace(/\*\*([^*]+)\*\*/g, '$1')
      .replace(/__([^_]+)__/g, '$1')
      .replace(/\*([^*]+)\*/g, '$1')
      .replace(/_([^_]+)_/g, '$1')
      // Convert links [text](url) to just text
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
      // Convert images ![alt](url) to [Image: alt]
      .replace(/!\[([^\]]*)\]\([^)]+\)/g, '[Image: $1]')
      // Remove heading markers (# ## ### etc.)
      .replace(/^#{1,6}\s+/gm, '')
      // Remove horizontal rules (---, ***, ___)
      .replace(/^[-*_]{3,}\s*$/gm, '---')
      // Convert list markers to simple dashes
      .replace(/^\s*[-*+]\s+/gm, '- ')
      .replace(/^\s*\d+\.\s+/gm, '- ')
      // Remove blockquote markers
      .replace(/^\s*>\s*/gm, '')
      // Clean up extra whitespace
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  },

  /**
   * Download as plain text file
   */
  downloadAsText(text: string, buttonEl: HTMLElement): void {
    const filename = `kea-answer-${getFileTimestamp()}.txt`;

    // Convert markdown to plain text
    const plainText = this.markdownToPlainText(text);
    downloadFile(plainText, filename, 'text/plain;charset=utf-8');

    // Show success feedback
    const icon = buttonEl.querySelector('i') as HTMLElement | null;
    if (icon) {
      updateButtonFeedback(buttonEl, icon, 'bi-file-earmark-text', 'bi-check-lg', ['text-success'], []);
    }
  },

  /**
   * Attach action handlers to a final answer card
   */
  attachToCard(cardId: string, answerText: string): void {
    const copyBtn = document.getElementById(`copy-btn-${cardId}`);
    const downloadBtn = document.getElementById(`download-btn-${cardId}`);

    if (copyBtn) {
      copyBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.copyToClipboard(answerText, copyBtn);
      });
    }

    if (downloadBtn) {
      downloadBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.downloadAsMarkdown(answerText, downloadBtn);
      });
    }
  }
};

// Make it globally available
declare global {
  interface Window {
    MessageActions: typeof MessageActions;
  }
}

window.MessageActions = MessageActions;
